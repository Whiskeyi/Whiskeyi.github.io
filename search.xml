<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编写程序，测量cacheline大小</title>
      <link href="/cacheline.html"/>
      <url>/cacheline.html</url>
      
        <content type="html"><![CDATA[<h2 id="编写程序，测量cacheline的大小"><a href="#编写程序，测量cacheline的大小" class="headerlink" title="编写程序，测量cacheline的大小"></a>编写程序，测量cacheline的大小</h2><h3 id="测量cacheline需要了解的信息"><a href="#测量cacheline需要了解的信息" class="headerlink" title="测量cacheline需要了解的信息"></a>测量cacheline需要了解的信息</h3><p>&emsp;&emsp;计算机带有两级或三级缓存，通常称为 L1、L2 和L3。L的等级越低代表离CPU越近，通过任务管理器和软件CPU-Z，我了解到在我的机器上，有一个6&times;64KB的L1数据缓存、一个6&times;64KB的L1指令缓存、一个6&times;256KB的L2缓存和一个12MB的L3数据缓存。<br>&emsp;&emsp;L1数据和指令缓存分别用于存放数据及执行数据的指令解码，L2二级缓存是L1一级缓存跟主内存之间的缓冲器，L3为L2与主内存之间的缓冲器。其中L3是计算 CPU共享的，L1、L2是CPU中核独享的。<br>&emsp;&emsp;cache分成多个组，每个组分成多个行。<br>&emsp;&emsp;如图中的8-way指的是8路组相连（8-way set associative），每个组里面有8个行。linesize是cache的基本单位，从主存向cache迁移数据都是按照linesize为单位替换的。比如linesize为64Byte，那么迁移必须一次迁移64Byte到cache。</p><p><img src="img/cacheline/task manager.png" alt="task manager"><br><img src="img/cacheline/CPU-Z.png" alt="CPU-Z"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];  </span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);  </span><br><span class="line"><span class="comment">//  for (int i = 0; i &lt; length; i++)    </span></span><br><span class="line"><span class="comment">//  &#123;  </span></span><br><span class="line"><span class="comment">//      arr[i] *= 3;  </span></span><br><span class="line"><span class="comment">//  &#125;  //循环1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i += <span class="number">16</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        arr[i] *= <span class="number">3</span>;  </span><br><span class="line">    &#125;   <span class="comment">//循环2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一个循环将数组的每个值乘3，第二个循环将每16个值乘3，第二个循环只做了第一个约6%的工作，但在现代机器上，两者几乎运行相同时间：在我机器上分别是34毫秒和35毫秒（如下图所示）。<br><img src="img/cacheline/time1.png" alt="time1"><br><img src="img/cacheline/time2.png" alt="time2"><br>&emsp;&emsp;两个循环花费相同时间的原因跟内存有关。循环执行时间长短由数组的内存访问次数决定的，而非整型数的乘法运算次数。这说明这两个循环的主存访问次数是相同的。<br>&emsp;&emsp;进一步探索这个例子。我们尝试使用不同的循环步长，而不仅仅是1和16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i += K)  </span><br><span class="line">arr[i] *= <span class="number">3</span>  </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过程序运行所得<br>&emsp;&emsp;K1=1、S1=0.3399<br>&emsp;&emsp;K2=2、S2=0.3408<br>&emsp;&emsp;K3=4、S3=0.3428<br>&emsp;&emsp;K4=8、S4=0.345<br>&emsp;&emsp;K5=16、S5=0.3498<br>&emsp;&emsp;K6=32、S6=0.2479<br>&emsp;&emsp;K7=64、S7=0.1714<br>&emsp;&emsp;K8=128、S8=0.1144<br>&emsp;&emsp;Tips：测试时尽量关闭其他应用程序，防止缓存的抢占，且要使用尽量大的测试次数，去掉偏离较大的值取中位数，以保证测试结果不具有随机性<br>&emsp;&emsp;将上面的数据导入Excel生成折线图</p><p><img src="img/cacheline/photo1.png" alt="photo1"><br>&emsp;&emsp;可以看出从16开始，每次步长加倍，运行时间急剧下降。<br>&emsp;&emsp;原因是CPU以64字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。由于16个整型数占用64字节（一个缓存行），for循环步长在1到16之间必定接触到相同数目的缓存行：即数组中所有的缓存行。当步长32，我们只有大约每两个缓存行接触一次，当步长为64，只有每四个接触一次。</p><h3 id="测量cache"><a href="#测量cache" class="headerlink" title="测量cache"></a>测量cache</h3><p>&emsp;&emsp;遍历一个整型数组，每16个值自增1——改变每个缓存行。当遍历到最后一个值，就重头开始。我们将使用不同的数组大小，可以看到当数组溢出一级缓存大小，程序运行的性能将急剧滑落。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];  </span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);  </span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>;  <span class="comment">//变量</span></span><br><span class="line">    <span class="keyword">int</span> lengthMod = length - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; steps; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        arr[(i * <span class="number">16</span>) % lengthMod]++;   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过列表可以推断出我们计算机各级缓存的大小。</p><h3 id="测量cache-line"><a href="#测量cache-line" class="headerlink" title="测量cache line"></a>测量cache line</h3><p>&emsp;&emsp;通过上一个实验可以得到L1 cache 的大小为 384kb，下面通过一个实验来测量自己电脑L1 cache line缓存行的大小，我们采用下面的方案（具体环境配置和详细代码[此处代码做了一部分修改]可参考文末博客）：<br>&emsp;&emsp;1）开辟一块内存<br>&emsp;&emsp;2）按照不同的步长stride进行若干次内存访问<br>&emsp;&emsp;3）记录时间，统计平均的数据吞吐量(kb/s)<br>&emsp;&emsp;4）画图分析，通过柱状图分析 stride 与 kbps 的关系<br>可行性分析：因为按照不同的步长，当我们的步长在L1 cache line之内，我们能够命中上一次访问数据时，载入L1 cache的数据行，而当我们的步长超出L1 cache line的大小，就会发生miss，拉低访问的时间（以此产生较大的偏差）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 1  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KB 1024  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB 1048576   </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::chrono::high_resolution_clock;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::chrono::duration;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::chrono::duration_cast;  </span><br><span class="line">  </span><br><span class="line">random_device rd;<span class="comment">//随机数生成  </span></span><br><span class="line"><span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_access</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">char</span>);  </span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">buffer</span> = <span class="keyword">new</span> <span class="keyword">char</span>[n];  </span><br><span class="line">    <span class="built_in">fill</span>(<span class="built_in">buffer</span>, <span class="built_in">buffer</span>+n, <span class="number">1</span>);  </span><br><span class="line">    <span class="function">uniform_int_distribution&lt;&gt; <span class="title">dis</span><span class="params">(<span class="number">0</span>, n<span class="number">-1</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">int</span> test_times = <span class="number">10000000</span> * <span class="number">10</span>;  </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random_index;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;test_times; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> index = dis(gen);  </span><br><span class="line">        random_index.push_back(index);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    high_resolution_clock::time_point t1 = high_resolution_clock::now();  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;test_times; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        sum += <span class="built_in">buffer</span>[random_index[i]];  </span><br><span class="line">    &#125;  </span><br><span class="line">    high_resolution_clock::time_point t2 = high_resolution_clock::now();  </span><br><span class="line">    duration&lt;<span class="keyword">double</span>&gt; time_span = duration_cast&lt;duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);  </span><br><span class="line">    <span class="keyword">double</span> dt = time_span.count();  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="built_in">size</span>/<span class="number">1024</span>)&lt;&lt;<span class="string">" "</span>&lt;&lt;(((<span class="keyword">double</span>)sum/<span class="number">1024.0</span>) / dt)&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">buffer</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stride_access</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">buffer</span>, <span class="keyword">int</span> stride, <span class="keyword">int</span> <span class="built_in">size</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">char</span>);  </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">    high_resolution_clock::time_point t1 = high_resolution_clock::now();  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;stride; j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i+=stride)  </span><br><span class="line">        &#123;  </span><br><span class="line">            sum += <span class="built_in">buffer</span>[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    high_resolution_clock::time_point t2 = high_resolution_clock::now();  </span><br><span class="line">    duration&lt;<span class="keyword">double</span>&gt; time_span = duration_cast&lt;duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);  </span><br><span class="line">    <span class="keyword">double</span> dt = time_span.count();  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stride&lt;&lt;<span class="string">" "</span>&lt;&lt;(((<span class="keyword">double</span>)sum/<span class="number">1024.0</span>) / dt)&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">400</span> * MB;  </span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">char</span>);  </span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">buffer</span> = <span class="keyword">new</span> <span class="keyword">char</span>[n];  </span><br><span class="line">    <span class="built_in">fill</span>(<span class="built_in">buffer</span>, <span class="built_in">buffer</span>+n, <span class="number">1</span>);   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; strides&#123;<span class="number">1</span>*B,<span class="number">2</span>*B,<span class="number">4</span>*B,<span class="number">8</span>*B,<span class="number">16</span>*B,<span class="number">32</span>*B,<span class="number">64</span>*B,<span class="number">96</span>*B,<span class="number">128</span>*B,<span class="number">192</span>*B,<span class="number">256</span>*B,<span class="number">512</span>*B,<span class="number">1024</span>*B,<span class="number">1536</span>*B,<span class="number">2048</span>*B&#125;;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s : strides)  </span><br><span class="line">    &#123;  </span><br><span class="line">        stride_access(<span class="built_in">buffer</span>, s, <span class="built_in">size</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    test();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果</p><p><img src="img/cacheline/result.png" alt="result"></p><p>&emsp;&emsp;将上面的数据生成柱状图</p><p><img src="img/cacheline/photo2.png" alt="photo2"></p><p>&emsp;&emsp;可以看到：<br>&emsp;&emsp;在步长 stride 位于 1-32 Byte 之间时，吞吐量几乎不变<br>&emsp;&emsp;在步长 stride 位于 16-128 Byte 之间，吞吐量逐步下降<br>&emsp;&emsp;在步长 stride 大于 128 Byte 之后，吞吐量几乎不变<br>&emsp;&emsp;当步长 stride 小于 L1 cache line 时，若干次访问才会发生一次 miss（访问的偏移量超出一行 L1 cache line），而当步长 stride 大于 L1 cache line，每次访问都会miss。<br>&emsp;&emsp;根据测试数据，推测 L1 cache line 约为 64 Byte，这与我们的测试结果相吻合。</p><p>参考博客：<br>&emsp;&emsp;<a href="http://igoro.com/archive/gallery-of-processor-cache-effects/" target="_blank" rel="noopener">http://igoro.com/archive/gallery-of-processor-cache-effects/</a><br>&emsp;&emsp;<a href="https://blog.csdn.net/qq_21125183/article/details/80590934" target="_blank" rel="noopener">https://blog.csdn.net/qq_21125183/article/details/80590934</a><br>&emsp;&emsp;<a href="https://blog.csdn.net/weixin_44176696/article/details/111873717" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44176696/article/details/111873717</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
